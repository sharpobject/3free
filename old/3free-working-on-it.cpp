#include <stdio.h>
#include <iostream>
#include <sstream>
#include <tchar.h>
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <fstream>

#define MAXBITS 256
#define MAXWORDS 16

int MAXLONGS=32/sizeof(unsigned long);

using namespace std;

unsigned short used[MAXWORDS];

//Work forward on used, backward on cantUse.

int lastLevel=1;
int start=0;
int N=17;
int setSize[MAXBITS+1]={0,1,2,2,3,4,4,4,4,5,5,6,6,7,8,8,8};  //setSize[k]=size of largest 3-free set on 1...k.
int goal=~1337; //Not leet :'(  Note: this value gets overwritten.
int NChosen=0;

int ones[256]={0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3,
 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3,
 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4,
 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6,
 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5,
 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4,
 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5,
 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5,
 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};
//Is it better to compute an array of size 65536, or to use a function like this?
//TEST THIS!!!
inline int nOnes(unsigned short s)
{
    return ones[s>>8]+ones[s&0xff];
}

//usableSize is not necessary because all lowest-level arrays are zero-terminated.
//TEST THIS!!!
unsigned short ***usable;

unsigned short startingArray[1460]={55404, 55350, 55347, 55341, 55323,
52251, 51813, 46170, 46107, 42579, 55400, 55396, 55384, 55372, 55348, 55346,
55345, 55340, 55337, 55334, 55333, 55331, 55322, 55321, 55318, 55315, 55309,
55307, 53608, 53545, 53464, 53450, 53356, 53350, 53338, 53302, 53299, 53293,
53275, 52250, 52249, 52246, 52243, 52237, 52235, 51812, 51809, 51781, 51749,
51308, 51301, 51254, 51251, 51245, 51227, 50822, 50203, 50017, 49862, 49765,
46168, 46162, 46154, 46106, 46105, 46102, 46099, 46093, 46091, 45473, 45272,
45233, 45209, 45164, 45158, 45146, 45110, 45107, 45101, 45083, 42578, 42577,
42563, 42518, 42515, 42074, 42067, 42011, 41797, 41681, 41669, 41555, 39244,
39181, 39020, 38966, 38963, 38957, 38939, 38090, 38027, 37978, 37915, 36109,
35867, 35653, 35429, 34499, 34387, 34189, 55392, 55376, 55368, 55364, 55344,
55336, 55332, 55330, 55329, 55320, 55316, 55314, 55313, 55308, 55306, 55305,
55302, 55301, 55299, 53664, 53640, 53600, 53576, 53544, 53537, 53513, 53456,
53448, 53442, 53424, 53410, 53400, 53386, 53352, 53348, 53346, 53336, 53330,
53324, 53322, 53318, 53300, 53298, 53297, 53292, 53289, 53286, 53285, 53283,
53274, 53273, 53270, 53267, 53261, 53259, 52248, 52244, 52242, 52241, 52236,
52234, 52233, 52230, 52229, 52227, 51808, 51780, 51777, 51748, 51745, 51718,
51717, 51715, 51304, 51300, 51297, 51288, 51281, 51276, 51269, 51252, 51250,
51249, 51244, 51241, 51238, 51237, 51235, 51226, 51225, 51222, 51219, 51213,
51211, 50820, 50818, 50694, 50693, 50691, 50568, 50456, 50441, 50316, 50314,
50310, 50202, 50201, 50198, 50195, 50189, 50187, 50016, 49985, 49953, 49860,
49858, 49798, 49764, 49761, 49734, 49733, 49731, 49701, 49584, 49560, 49512,
49505, 49449, 49368, 49356, 49354, 49350, 49332, 49318, 49260, 49254, 49253,
49251, 49242, 49235, 49206, 49203, 49197, 49179, 46160, 46152, 46146, 46104,
46100, 46098, 46097, 46092, 46090, 46089, 46086, 46085, 46083, 45472, 45441,
45408, 45380, 45345, 45317, 45264, 45256, 45232, 45217, 45208, 45201, 45193,
45160, 45156, 45154, 45144, 45138, 45132, 45130, 45126, 45108, 45106, 45105,
45100, 45097, 45094, 45093, 45091, 45082, 45081, 45078, 45075, 45069, 45067,
42576, 42562, 42561, 42516, 42514, 42513, 42502, 42501, 42499, 42260, 42245,
42072, 42066, 42065, 42058, 42051, 42010, 42009, 42006, 42003, 41997, 41995,
41796, 41793, 41748, 41733, 41680, 41668, 41665, 41620, 41617, 41605, 41554,
41553, 41542, 41541, 41539, 41494, 41491, 41392, 41377, 41364, 41349, 41313,
41285, 41176, 41169, 41164, 41157, 41140, 41137, 41125, 41113, 41101, 41068,
41062, 41061, 41059, 41050, 41043, 41014, 41011, 41005, 40987, 39240, 39236,
39180, 39177, 39173, 39016, 39012, 39000, 38988, 38964, 38962, 38961, 38956,
38953, 38950, 38949, 38947, 38938, 38937, 38934, 38931, 38925, 38923, 38088,
38082, 38026, 38025, 38019, 37976, 37970, 37962, 37914, 37913, 37910, 37907,
37901, 37899, 37281, 37257, 37224, 37196, 37161, 37133, 37080, 37066, 37041,
37027, 37017, 37003, 36972, 36966, 36954, 36918, 36915, 36909, 36891, 36120,
36116, 36108, 36105, 36101, 35928, 35921, 35866, 35865, 35862, 35859, 35853,
35851, 35652, 35649, 35604, 35589, 35428, 35425, 35409, 35397, 35380, 35377,
35365, 35350, 35347, 35148, 35141, 35085, 34924, 34917, 34870, 34867, 34861,
34843, 34498, 34497, 34438, 34437, 34435, 34386, 34385, 34371, 34326, 34323,
34188, 34185, 34181, 34061, 33994, 33987, 33933, 33931, 33882, 33875, 33819,
33633, 33605, 33489, 33478, 33477, 33475, 33381, 33363, 33165, 55360, 55328,
55312, 55304, 55300, 55298, 55297, 53632, 53568, 53536, 53512, 53505, 53440,
53408, 53392, 53384, 53378, 53344, 53328, 53320, 53316, 53314, 53296, 53288,
53284, 53282, 53281, 53272, 53268, 53266, 53265, 53260, 53258, 53257, 53254,
53253, 53251, 52240, 52232, 52228, 52226, 52225, 51776, 51744, 51716, 51714,
51713, 51296, 51280, 51272, 51268, 51265, 51248, 51240, 51236, 51234, 51233,
51224, 51220, 51218, 51217, 51212, 51210, 51209, 51206, 51205, 51203, 50816,
50692, 50690, 50689, 50560, 50448, 50440, 50433, 50312, 50308, 50306, 50200,
50196, 50194, 50193, 50188, 50186, 50185, 50182, 50181, 50179, 49984, 49952,
49921, 49856, 49796, 49794, 49760, 49732, 49730, 49729, 49700, 49697, 49670,
49669, 49667, 49568, 49552, 49544, 49504, 49480, 49473, 49456, 49448, 49441,
49432, 49417, 49360, 49352, 49348, 49346, 49328, 49316, 49314, 49304, 49300,
49292, 49290, 49286, 49256, 49252, 49250, 49249, 49240, 49234, 49233, 49228,
49226, 49222, 49221, 49219, 49204, 49202, 49201, 49196, 49193, 49190, 49189,
49187, 49178, 49177, 49174, 49171, 49165, 49163, 46144, 46096, 46088, 46084,
46082, 46081, 45440, 45376, 45344, 45316, 45313, 45248, 45216, 45200, 45192,
45185, 45152, 45136, 45128, 45124, 45122, 45104, 45096, 45092, 45090, 45089,
45080, 45076, 45074, 45073, 45068, 45066, 45065, 45062, 45061, 45059, 42560,
42512, 42500, 42498, 42497, 42256, 42244, 42241, 42064, 42056, 42050, 42049,
42008, 42004, 42002, 42001, 41996, 41994, 41993, 41990, 41989, 41987, 41792,
41744, 41732, 41729, 41664, 41616, 41604, 41601, 41552, 41540, 41538, 41537,
41492, 41490, 41489, 41478, 41477, 41475, 41376, 41360, 41348, 41345, 41312,
41284, 41281, 41264, 41249, 41236, 41221, 41168, 41160, 41156, 41153, 41136,
41124, 41121, 41112, 41108, 41105, 41100, 41097, 41093, 41064, 41060, 41058,
41057, 41048, 41042, 41041, 41036, 41034, 41030, 41029, 41027, 41012, 41010,
41009, 41004, 41001, 40998, 40997, 40995, 40986, 40985, 40982, 40979, 40973,
40971, 39232, 39176, 39172, 39169, 39008, 38992, 38984, 38980, 38960, 38952,
38948, 38946, 38945, 38936, 38932, 38930, 38929, 38924, 38922, 38921, 38918,
38917, 38915, 38080, 38024, 38018, 38017, 37968, 37960, 37954, 37912, 37908,
37906, 37905, 37900, 37898, 37897, 37894, 37893, 37891, 37280, 37256, 37249,
37216, 37192, 37188, 37160, 37153, 37132, 37129, 37125, 37072, 37064, 37058,
37040, 37026, 37025, 37016, 37009, 37002, 37001, 36995, 36968, 36964, 36962,
36952, 36946, 36940, 36938, 36934, 36916, 36914, 36913, 36908, 36905, 36902,
36901, 36899, 36890, 36889, 36886, 36883, 36877, 36875, 36112, 36104, 36100,
36097, 35920, 35912, 35905, 35864, 35860, 35858, 35857, 35852, 35850, 35849,
35846, 35845, 35843, 35648, 35600, 35588, 35585, 35424, 35408, 35396, 35393,
35376, 35364, 35361, 35348, 35346, 35345, 35334, 35333, 35331, 35144, 35140,
35137, 35096, 35092, 35084, 35081, 35077, 34920, 34916, 34913, 34904, 34897,
34892, 34885, 34868, 34866, 34865, 34860, 34857, 34854, 34853, 34851, 34842,
34841, 34838, 34835, 34829, 34827, 34496, 34436, 34434, 34433, 34384, 34370,
34369, 34324, 34322, 34321, 34310, 34309, 34307, 34184, 34180, 34177, 34072,
34068, 34060, 34057, 34053, 33992, 33986, 33985, 33932, 33930, 33929, 33926,
33925, 33923, 33880, 33874, 33873, 33866, 33859, 33818, 33817, 33814, 33811,
33805, 33803, 33632, 33604, 33601, 33584, 33569, 33556, 33541, 33488, 33476,
33474, 33473, 33428, 33425, 33414, 33413, 33411, 33380, 33377, 33362, 33361,
33350, 33349, 33347, 33332, 33329, 33317, 33302, 33299, 33200, 33185, 33176,
33172, 33164, 33161, 33157, 33128, 33121, 33100, 33093, 33065, 33037, 32984,
32977, 32972, 32970, 32966, 32965, 32963, 32948, 32945, 32934, 32933, 32931,
32921, 32909, 32907, 32876, 32870, 32869, 32867, 32858, 32851, 32822, 32819,
32813, 32795, 55296, 53504, 53376, 53312, 53280, 53264, 53256, 53252, 53250,
53249, 52224, 51712, 51264, 51232, 51216, 51208, 51204, 51202, 51201, 50688,
50432, 50304, 50192, 50184, 50180, 50178, 50177, 49920, 49792, 49728, 49696,
49668, 49666, 49665, 49536, 49472, 49440, 49424, 49416, 49409, 49344, 49312,
49296, 49288, 49284, 49282, 49248, 49232, 49224, 49220, 49218, 49217, 49200,
49192, 49188, 49186, 49185, 49176, 49172, 49170, 49169, 49164, 49162, 49161,
49158, 49157, 49155, 46080, 45312, 45184, 45120, 45088, 45072, 45064, 45060,
45058, 45057, 42496, 42240, 42048, 42000, 41992, 41988, 41986, 41985, 41728,
41600, 41536, 41488, 41476, 41474, 41473, 41344, 41280, 41248, 41232, 41220,
41217, 41152, 41120, 41104, 41096, 41092, 41089, 41056, 41040, 41032, 41028,
41026, 41025, 41008, 41000, 40996, 40994, 40993, 40984, 40980, 40978, 40977,
40972, 40970, 40969, 40966, 40965, 40963, 39168, 38976, 38944, 38928, 38920,
38916, 38914, 38913, 38016, 37952, 37904, 37896, 37892, 37890, 37889, 37248,
37184, 37152, 37128, 37124, 37121, 37056, 37024, 37008, 37000, 36994, 36993,
36960, 36944, 36936, 36932, 36930, 36912, 36904, 36900, 36898, 36897, 36888,
36884, 36882, 36881, 36876, 36874, 36873, 36870, 36869, 36867, 36096, 35904,
35856, 35848, 35844, 35842, 35841, 35584, 35392, 35360, 35344, 35332, 35330,
35329, 35136, 35088, 35080, 35076, 35073, 34912, 34896, 34888, 34884, 34881,
34864, 34856, 34852, 34850, 34849, 34840, 34836, 34834, 34833, 34828, 34826,
34825, 34822, 34821, 34819, 34432, 34368, 34320, 34308, 34306, 34305, 34176,
34064, 34056, 34052, 34049, 33984, 33928, 33924, 33922, 33921, 33872, 33864,
33858, 33857, 33816, 33812, 33810, 33809, 33804, 33802, 33801, 33798, 33797,
33795, 33600, 33568, 33552, 33540, 33537, 33472, 33424, 33412, 33410, 33409,
33376, 33360, 33348, 33346, 33345, 33328, 33316, 33313, 33300, 33298, 33297,
33286, 33285, 33283, 33184, 33168, 33160, 33156, 33153, 33120, 33096, 33092,
33089, 33072, 33064, 33057, 33048, 33044, 33036, 33033, 33029, 32976, 32968,
32964, 32962, 32961, 32944, 32932, 32930, 32929, 32920, 32916, 32913, 32908,
32906, 32905, 32902, 32901, 32899, 32872, 32868, 32866, 32865, 32856, 32850,
32849, 32844, 32842, 32838, 32837, 32835, 32820, 32818, 32817, 32812, 32809,
32806, 32805, 32803, 32794, 32793, 32790, 32787, 32781, 32779, 53248, 51200,
50176, 49664, 49408, 49280, 49216, 49184, 49168, 49160, 49156, 49154, 49153,
45056, 41984, 41472, 41216, 41088, 41024, 40992, 40976, 40968, 40964, 40962,
40961, 38912, 37888, 37120, 36992, 36928, 36896, 36880, 36872, 36868, 36866,
36865, 35840, 35328, 35072, 34880, 34848, 34832, 34824, 34820, 34818, 34817,
34304, 34048, 33920, 33856, 33808, 33800, 33796, 33794, 33793, 33536, 33408,
33344, 33312, 33296, 33284, 33282, 33281, 33152, 33088, 33056, 33040, 33032,
33028, 33025, 32960, 32928, 32912, 32904, 32900, 32898, 32897, 32864, 32848,
32840, 32836, 32834, 32833, 32816, 32808, 32804, 32802, 32801, 32792, 32788,
32786, 32785, 32780, 32778, 32777, 32774, 32773, 32771, 49152, 40960 ,36864,
34816, 33792, 33280, 33024, 32896, 32832, 32800, 32784, 32776, 32772, 32770,
32769, 32768, 0};
//Compute starting array (Done, see the 100+ lines of ugly directly above?)

FILE* outputfile;

void initialize()
{
    outputfile = fopen("output.txt", "wt");
    //55404 is the numerically largest representation of 3-free set on 16 bits.
    usable=new unsigned short**[55405];
    //6502029 is the number of unique one-dimensional arrays.
    //4151 is the number of 3-free sets on 16 bits, so it works as a bound.
    unsigned short *theArrays[6502029],buffer[4151];
    ifstream arrayIn("onesortedfile/sortedfile.txt");
    unsigned short tmp;
    for(int i=0;i<6502029;i++)
    {
//       if(i%100000==0)
//            printf("Reading line %d of sortedfile.txt\n",i);
        int idx=0;
        arrayIn>>tmp;
        while(tmp!=0)
        {
            buffer[idx++]=tmp;
            arrayIn>>tmp;
        }
        buffer[idx++]=tmp;
        theArrays[i]=new unsigned short[idx];
        for(int j=0;j<idx;j++)
            theArrays[i][j]=buffer[j];
    }
    if(arrayIn>>tmp)
        printf("WARNING! sortedfile.txt has not been completely read.\n");
    arrayIn.close();
    ifstream goodOnesListIn("goodoneslist/goodoneslist.txt");
    for(int i=0;i<4151;i++)
    {
//        printf("Opening file %d of 4151.\n",i+1);
        goodOnesListIn>>tmp;
        stringstream stream("usableindices/");
        stream<<tmp;
        stream<<".txt";
        usable[tmp]=new unsigned short*[0x10000];
        int tmpInt;
        ifstream arrayIndicesIn(stream.str().c_str());
        for(int j=0;j<0x10000;j++)
        {
            arrayIndicesIn>>tmpInt;
            usable[tmp][j]=theArrays[tmpInt];
        }
        arrayIndicesIn.close();
    }
}

inline void reset(unsigned short* cantUse)
{
    lastLevel=((N-1)/16);
    goal=setSize[N-1]+1;
    start=GetTickCount();
    NChosen=0;
    //Zero used, set ones in cantUse.
    for(int i=0;i<MAXWORDS;i++)
    {
        used[i]=0;
        cantUse[i]=0xffff;
    }
    //Set zeros in cantUse to fill the scope of the choosable numbers.
    for(int i=0;i<N;i++)
        cantUse[MAXWORDS-1-(i/16)]^=((0x01)<<(i%16));
    if(N&1)
        cantUse[MAXWORDS-1-((N/2)/16)]^=((0x01)<<((N/2)%16));
}

inline void excludeBit(int whichWord,int whichBit,unsigned short* cantUse)
{
    int howFarToShift=MAXBITS-((whichWord*32)+(whichBit*2))-1;
    if(howFarToShift>0)  //Then we shift used to the right!
    {
        int bitShift=howFarToShift&0x0f,wordShift=howFarToShift>>4;
        //First, handle the whole words.
        for(int i=0;i<whichWord;i++)
        {
            cantUse[wordShift+i]|=(used[i]>>bitShift);
            cantUse[wordShift+i+1]|=(used[i]<<(16-bitShift));
        }
        //No need to worry about the bits in whichWord, we know it's empty.
        //We're done.
    }
    else    //Shift to the left instead.
    {
        howFarToShift=-howFarToShift;
        int bitShift=howFarToShift&15,wordShift=howFarToShift>>4;
        for(int i=0;(i+wordShift)!=whichWord;i++)
        {
            cantUse[i]|=(used[i+wordShift]<<bitShift);
            cantUse[i]|=(used[i+wordShift+1]>>(16-bitShift));        
        }
        //Done.
    }
}

inline void copyAToB(unsigned short* ac,unsigned short* bc)
{
    unsigned long* a=(unsigned long*)ac,*b=(unsigned long*)bc;
    for(int i=0;i<MAXLONGS;i++)
        b[i]=a[i];
}

inline void orAToB(unsigned short* ac,unsigned short* bc)
{
    unsigned long* a=(unsigned long*)ac,*b=(unsigned long*)bc;
    for(int i=0;i<MAXLONGS;i++)
        b[i]|=a[i];
}

bool choose(int level,unsigned short* choices,unsigned short* cantUse)
{
    if(cantUse[MAXWORDS-1-((N-1)/16)]&((0x01)<<((N-1)%16)))
        return false;
    if(level==lastLevel)
        if((nOnes(choices[0])+NChosen)==goal)
        {
            used[level]=choices[0];
            return true;
        }
        else
            return false;
    unsigned short toOr[16][MAXWORDS];
    unsigned short toPass[MAXWORDS];
    for(int i=0;i<16;i++)
    {
        copyAToB(cantUse,toOr[i]);
        excludeBit(level,i,toOr[i]);
    }
    for(int i=0;;i++)
    {
        unsigned short subseq=choices[i];
        /*If we have chosen c and we need to choose (k=goal-c) out of the
         remaining m numbers, quit if a(m)<k.  This should offer a HUGE boost,
         and improves itself dynamically based on previous results.*/
        if(setSize[N-(level+1)*16]<goal-NChosen-nOnes(subseq))
            return false;
        used[level]=subseq;
        NChosen+=nOnes(subseq);
        copyAToB(cantUse,toPass);
        for(int j=0;j<16;j++)
            if(subseq&(0x8000>>j))
                orAToB(toOr[j],toPass);
        if(choose(level+1,usable[subseq][toPass[MAXWORDS-1-(level+1)]],toPass))
            return true;
        NChosen-=nOnes(subseq);
        //all lowest-level arrays are 0-terminated.
        if(subseq==0) break;
    }
    used[level]=0;
    return false;
}
//WORK IS COMPLETE UP TO THIS POINT.
int main(int argc, char* argv)
{
    initialize();      
    if(!outputfile)
    {
        printf("It don't work, chief.");
        return 0;
    }
    if(sizeof(short)!=2)
    {
        printf("sizeof(short) is borked.");
        return 0;
    }
    unsigned short cantUse[MAXWORDS];
    for(;N<=MAXBITS;N++)
    {
        //Set everything up for the next test.
        reset(cantUse);
        
        fprintf(outputfile, "Looking for a set of size %d in 1...%d: ",goal,N);
        printf("Looking for a set of size %d in 1...%d: ",goal,N);
        
        bool itWorks=choose(0,startingArray,cantUse);
        setSize[N]=setSize[N-1];
        if(itWorks)
        {
            setSize[N]++;
            printf("It exists.\n");
            fprintf(outputfile,"It exists.\n");
            for(int i=0;i<MAXBITS;i++)
            {
                if(used[i/16]&(0x8000>>(i&15)))
                {
                    printf("%d ",i+1);
                    fprintf(outputfile,"%d ",i+1);
                }
            }
            printf("\n");
            fprintf(outputfile,"\n");
        }
        else
        {
            printf("There isn't one.\n");
            fprintf(outputfile,"There isn't one.\n");
        }
        printf("(%0.2f seconds)\n",
            (float)( GetTickCount() - start ) / 1000.0f);
        fprintf(outputfile, "(%0.2f seconds)\n",
            (float)( GetTickCount() - start ) / 1000.0f );
        fflush(outputfile);
    }
    if(outputfile)
        fclose(outputfile);
    return 0;
}
